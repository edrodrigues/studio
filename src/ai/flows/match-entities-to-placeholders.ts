
'use server';
/**
 * @fileOverview Matches template placeholders to extracted entities using AI semantic understanding.
 * 
 * This flow solves the problem where placeholder names don't exactly match entity names.
 * For example, a placeholder "REITOR" should match entity "NOME_DO_REITOR".
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';

const MatchEntitiesToPlaceholdersInputSchema = z.object({
    placeholders: z.array(z.string()).describe('Array of placeholder names from the template'),
    entities: z.record(z.string(), z.any()).describe('Object mapping entity names to their values'),
    entityDescriptions: z.record(z.string(), z.string()).optional().describe('Optional descriptions of what each entity represents'),
});

export type MatchEntitiesToPlaceholdersInput = z.infer<
    typeof MatchEntitiesToPlaceholdersInputSchema
>;

const MatchEntitiesToPlaceholdersOutputSchema = z.object({
    matches: z.array(z.object({
        placeholder: z.string().describe('The placeholder name from the template'),
        entityKey: z.string().describe('The entity key that should fill this placeholder'),
    })).describe('Array of placeholder-to-entity mappings. Only include placeholders that have a clear match.'),
});

export type MatchEntitiesToPlaceholdersOutput = z.infer<
    typeof MatchEntitiesToPlaceholdersOutputSchema
>;

export async function matchEntitiesToPlaceholders(
    input: MatchEntitiesToPlaceholdersInput
): Promise<MatchEntitiesToPlaceholdersOutput> {
    return matchEntitiesFlow(input);
}

const matchEntitiesPrompt = ai.definePrompt({
    name: 'matchEntitiesPrompt',
    input: { schema: MatchEntitiesToPlaceholdersInputSchema },
    output: {
        format: 'json',
        schema: MatchEntitiesToPlaceholdersOutputSchema,
    },
    prompt: `Tarefa:
Você é um assistente especialista em análise de contratos. Sua tarefa é vincular "Placeholders" (variáveis de um modelo) a "Entidades" (valores extraídos de um documento).

Objetivo:
Para cada Placeholder, encontre a Entidade que melhor o preenche. O Placeholder pode vir no formato "<nome da variável>" ou apenas "nome da variável".

Dados de Entrada:
-----------------
1. Placeholders (do template):
{{#each placeholders}}
- {{this}}
{{/each}}

2. Entidades Disponíveis (extraídas):
{{#each entities}}
- Key: "{{@key}}", Valor: "{{this}}"
{{/each}}

3. Descrições (opcional):
{{#if entityDescriptions}}
{{#each entityDescriptions}}
- {{@key}}: {{this}}
{{/each}}
{{/if}}

Lógica de Correspondência e Limpeza:
1. **Limpeza de Placeholders:** Se um placeholder estiver envolto em sinais de menor/maior (ex: "<nome>"), considere apenas o texto interno ("nome") para o match semântico.
2. **Ignorar Ruído:** Se um placeholder for uma tag HTML (ex: "EM", "LI", "P", "/EM", "/LI") ou começar com "/", IGNORE-O. Não faça match.

Regras de Matching (Prioridade Descrescente):
1. Correspondência Exata ou Normalizada: "<NOME_PARCEIRO>" ou "NOME_PARCEIRO" == "Nome Parceiro"
2. Semântica/Sinônimos: "<Contratada>" pode ser preenchido por "RAZAO_SOCIAL", "NOME_DA_EMPRESA", "INSTITUICAO_PARCEIRA".
3. Conteúdo/Valor: Se o placeholder é "<Data de Início>" e a única entidade com formato de data (24/11/2025) é "DATA_ASSINATURA", faça o match.
4. Inferência Lógica Baseada no Contexto:
    - "GESTor" pode ser "COORDENADOR_DO_PROJETO".
    - "UFPE" geralmente é a "INSTITUICAO_EXECUTORA" ou apenas "INSTITUICAO".

Instruções Finais:
- Retorne APENAS o JSON válido.
- Se não houver match confiável ou se o placeholder for ruído HTML, NÃO inclua o placeholder na lista de matches.
`,
});

const matchEntitiesFlow = ai.defineFlow(
    {
        name: 'matchEntitiesFlow',
        inputSchema: MatchEntitiesToPlaceholdersInputSchema,
        outputSchema: MatchEntitiesToPlaceholdersOutputSchema,
    },
    async input => {
        console.log('--- MATCH ENTITIES DEBUG ---');
        console.log('Placeholders:', JSON.stringify(input.placeholders));
        console.log('Entities:', JSON.stringify(input.entities));

        const llmResponse = await matchEntitiesPrompt(input);
        const output = llmResponse.output;

        if (!output) {
            throw new Error('No output was generated by the AI.');
        }

        return {
            matches: output.matches,
        };
    }
);
