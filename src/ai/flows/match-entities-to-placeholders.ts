
'use server';
/**
 * @fileOverview Matches template placeholders to extracted entities using AI semantic understanding.
 * 
 * This flow solves the problem where placeholder names don't exactly match entity names.
 * For example, a placeholder "REITOR" should match entity "NOME_DO_REITOR".
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';

const MatchEntitiesToPlaceholdersInputSchema = z.object({
    placeholders: z.array(z.string()).describe('Array of placeholder names from the template'),
    entities: z.record(z.string(), z.any()).describe('Object mapping entity names to their values'),
    entityDescriptions: z.record(z.string(), z.string()).optional().describe('Optional descriptions of what each entity represents'),
});

export type MatchEntitiesToPlaceholdersInput = z.infer<
    typeof MatchEntitiesToPlaceholdersInputSchema
>;

const MatchEntitiesToPlaceholdersOutputSchema = z.object({
    matches: z.array(z.object({
        placeholder: z.string().describe('The placeholder name from the template'),
        entityKey: z.string().describe('The entity key that should fill this placeholder'),
    })).describe('Array of placeholder-to-entity mappings. Only include placeholders that have a clear match.'),
});

export type MatchEntitiesToPlaceholdersOutput = z.infer<
    typeof MatchEntitiesToPlaceholdersOutputSchema
>;

export async function matchEntitiesToPlaceholders(
    input: MatchEntitiesToPlaceholdersInput
): Promise<MatchEntitiesToPlaceholdersOutput> {
    return matchEntitiesFlow(input);
}

const matchEntitiesPrompt = ai.definePrompt({
    name: 'matchEntitiesPrompt',
    input: { schema: MatchEntitiesToPlaceholdersInputSchema },
    output: {
        format: 'json',
        schema: MatchEntitiesToPlaceholdersOutputSchema,
    },
    prompt: `Tarefa:
Você receberá uma lista de placeholders (variáveis) de um template de contrato e uma lista de entidades (informações extraídas de documentos).
Sua tarefa é fazer o matching inteligente entre placeholders e entidades, identificando qual entidade deve preencher qual placeholder.

Placeholders do template:
{{#each placeholders}}
- {{this}}
{{/each}}

Entidades disponíveis:
{{#each entities}}
- {{@key}}: {{this}}
{{/each}}

{{#if entityDescriptions}}
Descrições das entidades (quando disponíveis):
{{#each entityDescriptions}}
- {{@key}}: {{this}}
{{/each}}
{{/if}}

Instruções:
1. Para cada placeholder, identifique qual entidade disponível melhor corresponde semanticamente a ele
2. Use compreensão semântica, não apenas matching exato de string
3. Exemplos de matching correto:
   - Placeholder "REITOR" deve corresponder a entidade "NOME_DO_REITOR"
   - Placeholder "UNIVERSIDADE" deve corresponder a "NOME_DA_UNIVERSIDADE"
   - Placeholder "CNPJ" deve corresponder a "CNPJ_DA_INSTITUICAO"
   - Placeholder "DATA_INICIO" deve corresponder a "DATA_DE_INICIO_DO_PROJETO"
4. Se um placeholder não tiver uma entidade correspondente clara, NÃO inclua ele no resultado
5. Priorize matches mais específicos e completos

Output esperado:
Um array JSON de objetos, onde cada objeto tem:
- "placeholder": o nome do placeholder do template
- "entityKey": o nome da entidade que deve preenchê-lo

Exemplo de output:
{
  "matches": [
    { "placeholder": "REITOR", "entityKey": "NOME_DO_REITOR" },
    { "placeholder": "UNIVERSIDADE", "entityKey": "NOME_DA_UNIVERSIDADE" },
    { "placeholder": "CNPJ", "entityKey": "CNPJ_DA_INSTITUICAO" }
  ]
}

IMPORTANTE: Retorne APENAS o JSON, sem explicações adicionais.
`,
});

const matchEntitiesFlow = ai.defineFlow(
    {
        name: 'matchEntitiesFlow',
        inputSchema: MatchEntitiesToPlaceholdersInputSchema,
        outputSchema: MatchEntitiesToPlaceholdersOutputSchema,
    },
    async input => {
        const llmResponse = await matchEntitiesPrompt(input);
        const output = llmResponse.output;

        if (!output) {
            throw new Error('No output was generated by the AI.');
        }

        return {
            matches: output.matches,
        };
    }
);
