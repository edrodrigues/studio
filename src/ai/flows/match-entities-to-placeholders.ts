
'use server';
/**
 * @fileOverview Matches template placeholders to extracted entities using AI semantic understanding.
 * 
 * This flow solves the problem where placeholder names don't exactly match entity names.
 * For example, a placeholder "REITOR" should match entity "NOME_DO_REITOR".
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';

const MatchEntitiesToPlaceholdersInputSchema = z.object({
    placeholders: z.array(z.string()).describe('Array of placeholder names from the template'),
    entities: z.record(z.string(), z.any()).describe('Object mapping entity names to their values'),
    entityDescriptions: z.record(z.string(), z.string()).optional().describe('Optional descriptions of what each entity represents'),
});

export type MatchEntitiesToPlaceholdersInput = z.infer<
    typeof MatchEntitiesToPlaceholdersInputSchema
>;

const MatchEntitiesToPlaceholdersOutputSchema = z.object({
    matches: z.array(z.object({
        placeholder: z.string().describe('The placeholder name from the template'),
        entityKey: z.string().describe('The entity key that should fill this placeholder'),
    })).describe('Array of placeholder-to-entity mappings. Only include placeholders that have a clear match.'),
});

export type MatchEntitiesToPlaceholdersOutput = z.infer<
    typeof MatchEntitiesToPlaceholdersOutputSchema
>;

export async function matchEntitiesToPlaceholders(
    input: MatchEntitiesToPlaceholdersInput
): Promise<MatchEntitiesToPlaceholdersOutput> {
    return matchEntitiesFlow(input);
}

const matchEntitiesPrompt = ai.definePrompt({
    name: 'matchEntitiesPrompt',
    input: { schema: MatchEntitiesToPlaceholdersInputSchema },
    output: {
        format: 'json',
        schema: MatchEntitiesToPlaceholdersOutputSchema,
    },
    prompt: `Tarefa:
Você receberá uma lista de placeholders (variáveis) de um template de contrato e uma lista de entidades (informações extraídas de documentos).
Sua tarefa é fazer o matching inteligente entre placeholders e entidades, identificando qual entidade deve preencher qual placeholder.

Placeholders do template:
{{#each placeholders}}
- {{this}}
{{/each}}

Entidades disponíveis:
{{#each entities}}
- {{@key}}: {{this}}
{{/each}}

{{#if entityDescriptions}}
Descrições das entidades (quando disponíveis):
{{#each entityDescriptions}}
- {{@key}}: {{this}}
{{/each}}
{{/if}}

Instruções CRÍTICAS:
1. Matching SEMÂNTICO: Entenda o significado. Não se prenda a palavras exatas.
2. Ignore artigos, preposições e palavras comuns como "Nome", "Valor", "Data", "do", "da".
   - Ex: "Parceiro" DEVE dar match com "Nome do Parceiro".
   - Ex: "Instituição" DEVE dar match com "UFPE" (se for a única instituição).
3. Entidades Parciais: Se o placeholder for genérico (ex: "RG") e a entidade for específica (ex: "RG do Gestor"), considere o match se fizer sentido no contexto.
4. Normalize maiúsculas/minúsculas e acentos mentalmente.
5. Priorize as entidades com valores mais ricos/completos.
6. Se houver dúvida razoável, faça o match mais provável ao invés de deixar vazio. O usuário pode corrigir depois.

Output esperado:
Um array JSON de objetos:
[
  { "placeholder": "NOME_NO_TEMPLATE", "entityKey": "NOME_NA_LISTA_ENTIDADES" }
]

IMPORTANTE: Retorne APENAS o JSON.
`,
});

const matchEntitiesFlow = ai.defineFlow(
    {
        name: 'matchEntitiesFlow',
        inputSchema: MatchEntitiesToPlaceholdersInputSchema,
        outputSchema: MatchEntitiesToPlaceholdersOutputSchema,
    },
    async input => {
        const llmResponse = await matchEntitiesPrompt(input);
        const output = llmResponse.output;

        if (!output) {
            throw new Error('No output was generated by the AI.');
        }

        return {
            matches: output.matches,
        };
    }
);
